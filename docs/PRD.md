# 커피 주문 앱

## 1. 프로젝트 개요

### 1.1 프로젝트명
커피 주문 앱

### 1.2 프로젝트 목적
사용자가 커피 메뉴를 주문하고, 관리자가 주문을 관리할 수 있는 간단한 풀스택 웹 앱

### 1.3 개발 범위
- 주문하기 화면(메뉴 선택 및 장바구니 기능)
- 관리자 화면(재고 관리 및 주문 상태 관리)
- 데이터를 생성/조회/수정/삭제할 수 있는 기능

## 2. 기술 스택
- 프런트엔드: HTML, CSS, 리액트, 자바스크립트
- 백엔드: Node.js, Express
- 데이터베이스: PostgreSQL

## 3. 기본 사항
- 프런트엔드와 백엔드를 따로 개발
- 기본적인 웹 기술만 사용
- 학습 목적이므로 사용자 인증이나 결제 기능은 제외
- 메뉴는 커피 메뉴만 있음

## 4. 주문하기 화면 상세 설계

### 4.1 화면 구성
주문하기 화면은 크게 3개의 섹션으로 구성됩니다:
1. **상단 헤더**: 앱 로고, 네비게이션 버튼
2. **상품 목록**: 메뉴 카드들
3. **장바구니**: 선택한 상품과 총 금액

### 4.2 상단 헤더
- **앱 로고**: 왼쪽 상단에 'COZY' 로고 표시
- **네비게이션 버튼**: 
  - '주문하기' 버튼: 현재 화면임을 나타내는 활성 상태 (녹색 테두리)
  - '관리자' 버튼: 관리자 화면으로 이동하는 일반 버튼

### 4.3 상품 목록 섹션
각 상품은 카드 형태로 표시되며, 가로로 3개씩 배치됩니다.

#### 4.3.1 상품 카드 구성 요소
- **상품 이미지**: 상단에 이미지 플레이스홀더
- **상품명**: 굵은 글씨로 표시
- **가격**: 상품명 아래에 표시 (원 단위)
- **설명**: 상품에 대한 간단한 설명
- **옵션 선택**:
  - '샷 추가 (+500원)': 체크박스 형태
  - '시럽 추가 (+0원)': 체크박스 형태 (무료)
- **담기 버튼**: 회색 테두리의 버튼

#### 4.3.2 기본 메뉴
1. **아메리카노(ICE)**: 4,000원
2. **아메리카노(HOT)**: 4,000원  
3. **카페라떼**: 5,000원

### 4.4 장바구니 섹션
화면 하단에 고정되어 있으며, 실시간으로 업데이트됩니다.

#### 4.4.1 장바구니 구성 요소
- **제목**: '장바구니' 텍스트
- **담긴 상품 목록**: 
  - 상품명과 옵션 정보 표시
  - 수량 표시 (예: X 1, X 2)
  - 개별 가격 표시
- **총 금액**: 
  - '총 금액' 레이블과 함께 굵은 글씨로 표시
  - 실시간으로 계산되어 업데이트
- **주문하기 버튼**: 회색 테두리의 최종 주문 버튼

#### 4.4.2 가격 계산 로직
- 기본 상품 가격 + 옵션 추가 비용
- 샷 추가: +500원
- 시럽 추가: +0원
- 수량별 가격 계산

### 4.5 사용자 인터랙션
1. **상품 선택**: 상품 카드에서 옵션 선택 후 '담기' 버튼 클릭
2. **옵션 선택**: 체크박스를 통한 옵션 선택 (다중 선택 가능)
3. **장바구니 확인**: 하단 장바구니에서 선택한 상품과 총 금액 확인
4. **주문 완료**: '주문하기' 버튼 클릭으로 주문 완료

### 4.6 반응형 디자인
- 데스크톱 환경에 최적화
- 카드 레이아웃은 가로 3개 고정
- 장바구니는 하단 고정으로 항상 보이도록 설계

### 4.7 상태 관리
- **장바구니 상태**: 선택한 상품들의 배열로 관리
- **가격 계산**: 실시간으로 총 금액 계산 및 업데이트
- **옵션 상태**: 각 상품별로 선택된 옵션 정보 저장

## 5. 관리자 화면 상세 설계

### 5.1 화면 구성
관리자 화면은 크게 4개의 섹션으로 구성됩니다:
1. **상단 헤더**: 앱 로고, 네비게이션 버튼
2. **관리자 대시보드**: 주문 상태 요약
3. **재고 현황**: 상품별 재고 관리
4. **주문 현황**: 대기 중인 주문 목록 및 처리

### 5.2 상단 헤더
- **앱 로고**: 왼쪽 상단에 'COZY' 로고 표시
- **네비게이션 버튼**: 
  - '주문하기' 버튼: 주문 화면으로 이동하는 일반 버튼
  - '관리자' 버튼: 현재 화면임을 나타내는 활성 상태 (어두운 테두리)

### 5.3 관리자 대시보드 섹션
주문 상태에 대한 전체적인 요약 정보를 제공합니다.

#### 5.3.1 대시보드 구성 요소
- **제목**: '관리자 대시보드'
- **주문 상태 요약**: 
  - 총 주문 수
  - 주문 접수 수
  - 제조 중 수
  - 제조 완료 수
- **실시간 업데이트**: 주문 상태 변경 시 자동으로 업데이트

#### 5.3.2 주문 상태 분류
1. **주문 접수**: 고객이 주문을 완료한 상태
2. **제조 중**: 관리자가 주문을 접수하여 제조를 시작한 상태
3. **제조 완료**: 제조가 완료되어 픽업 대기 중인 상태

### 5.4 재고 현황 섹션
각 상품의 재고를 실시간으로 관리할 수 있는 섹션입니다.

#### 5.4.1 재고 카드 구성 요소
- **상품명**: 각 메뉴명 표시
- **현재 재고**: 숫자로 표시 (예: "10개")
- **재고 조절 버튼**: 
  - "+" 버튼: 재고 증가
  - "-" 버튼: 재고 감소

#### 5.4.2 재고 관리 기능
- **실시간 업데이트**: 주문 처리 시 재고 자동 감소
- **수동 조절**: 관리자가 직접 재고 수량 조절 가능
- **재고 부족 알림**: 재고가 일정 수준 이하로 떨어질 시 알림

#### 5.4.3 관리 대상 상품
1. **아메리카노 (ICE)**: 기본 재고 10개
2. **아메리카노 (HOT)**: 기본 재고 10개
3. **카페라떼**: 기본 재고 10개

### 5.5 주문 현황 섹션
대기 중인 주문들을 관리하고 처리하는 섹션입니다.

#### 5.5.1 주문 목록 구성 요소
- **제목**: '주문 현황'
- **주문 카드**: 각 주문별로 개별 카드로 표시
- **주문 정보**:
  - 주문 시간 (예: "7월 31일 13:00")
  - 주문 상품 및 수량 (예: "아메리카노(ICE) x 1")
  - 주문 금액 (예: "4,000원")
- **처리 버튼**: '주문 접수' 버튼

#### 5.5.2 주문 처리 플로우
1. **주문 접수**: 고객의 주문을 확인하고 접수 처리
2. **제조 시작**: 접수된 주문을 제조 중 상태로 변경
3. **제조 완료**: 제조 완료 상태로 변경

#### 5.5.3 주문 상태 변경
- **주문 접수 → 제조 중**: '제조 시작' 버튼
- **제조 중 → 제조 완료**: '제조 완료' 버튼
- **제조 완료**: 고객 픽업 대기 상태

### 5.6 사용자 인터랙션
1. **재고 관리**: "+", "-" 버튼으로 재고 수량 조절
2. **주문 처리**: 주문 카드의 버튼으로 주문 상태 변경
3. **화면 전환**: 헤더의 '주문하기' 버튼으로 주문 화면 이동

### 5.7 실시간 업데이트
- **주문 상태**: 새로운 주문 접수 시 자동 업데이트
- **재고 현황**: 주문 처리 시 재고 자동 감소
- **대시보드**: 주문 상태 변경 시 요약 정보 자동 업데이트

### 5.8 데이터 관리
- **주문 데이터**: 주문 ID, 시간, 상품, 수량, 금액, 상태
- **재고 데이터**: 상품별 현재 재고 수량
- **상태 추적**: 각 주문의 상태 변경 이력 관리

### 5.9 반응형 디자인
- 데스크톱 환경에 최적화
- 재고 카드는 가로 3개 고정 배치
- 주문 목록은 세로 스크롤로 확장 가능
- 섹션별로 명확한 구분과 적절한 여백

## 6. 백엔드 개발 PRD

### 6.1 데이터 모델 설계

#### 6.1.1 Menus 테이블
커피 메뉴 정보를 저장하는 테이블입니다.

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-------------|----------|------|
| id | SERIAL | PRIMARY KEY | 메뉴 고유 ID |
| name | VARCHAR(100) | NOT NULL | 커피 이름 |
| description | TEXT | | 메뉴 설명 |
| price | INTEGER | NOT NULL | 가격 (원) |
| image | VARCHAR(255) | | 이미지 URL 또는 이모지 |
| stock_quantity | INTEGER | NOT NULL DEFAULT 0 | 재고 수량 |
| created_at | TIMESTAMP | DEFAULT NOW() | 생성 시간 |
| updated_at | TIMESTAMP | DEFAULT NOW() | 수정 시간 |

#### 6.1.2 Options 테이블
메뉴 옵션 정보를 저장하는 테이블입니다.

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-------------|----------|------|
| id | SERIAL | PRIMARY KEY | 옵션 고유 ID |
| name | VARCHAR(100) | NOT NULL | 옵션 이름 |
| price | INTEGER | NOT NULL DEFAULT 0 | 옵션 추가 가격 (원) |
| menu_id | INTEGER | FOREIGN KEY | 연결할 메뉴 ID |
| created_at | TIMESTAMP | DEFAULT NOW() | 생성 시간 |

#### 6.1.3 Orders 테이블
주문 정보를 저장하는 테이블입니다.

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-------------|----------|------|
| id | SERIAL | PRIMARY KEY | 주문 고유 ID |
| order_time | TIMESTAMP | NOT NULL DEFAULT NOW() | 주문 일시 |
| order_items | JSONB | NOT NULL | 주문 내용 (메뉴, 수량, 옵션, 금액) |
| total_amount | INTEGER | NOT NULL | 총 주문 금액 |
| status | VARCHAR(20) | NOT NULL DEFAULT 'pending' | 주문 상태 |
| created_at | TIMESTAMP | DEFAULT NOW() | 생성 시간 |
| updated_at | TIMESTAMP | DEFAULT NOW() | 수정 시간 |

### 6.2 사용자 흐름 및 데이터 스키마

#### 6.2.1 메뉴 조회 흐름
1. **프론트엔드**: 메뉴 목록 조회 요청
2. **백엔드**: Menus 테이블에서 모든 메뉴 정보 조회
3. **백엔드**: Options 테이블에서 각 메뉴의 옵션 정보 조회
4. **백엔드**: 재고 수량 정보와 함께 메뉴 목록 반환
5. **프론트엔드**: 받은 데이터로 메뉴 카드 렌더링

#### 6.2.2 주문 처리 흐름
1. **프론트엔드**: 장바구니 정보와 함께 주문 요청
2. **백엔드**: 주문 정보를 Orders 테이블에 저장
3. **백엔드**: 주문된 메뉴의 재고 수량을 Menus 테이블에서 차감
4. **백엔드**: 주문 완료 응답 및 주문 ID 반환
5. **프론트엔드**: 주문 완료 알림 표시

#### 6.2.3 주문 상태 관리 흐름
1. **프론트엔드**: 관리자 화면에서 주문 목록 조회 요청
2. **백엔드**: Orders 테이블에서 주문 목록 조회 (상태별 필터링)
3. **백엔드**: 주문 목록과 상태별 통계 반환
4. **프론트엔드**: 주문 현황 화면에 데이터 표시
5. **상태 변경**: 관리자가 주문 상태 변경 시 Orders 테이블 업데이트

### 6.3 API 설계

#### 6.3.1 메뉴 관련 API

##### GET /api/menus
메뉴 목록을 조회합니다.
- **요청**: 없음
- **응답**:
```json
{
  "success": true,
  "data": [
    {
      "id": 1,
      "name": "아메리카노(ICE)",
      "description": "깔끔하고 시원한 아이스 아메리카노",
      "price": 4000,
      "image": "🧊☕",
      "stock_quantity": 10,
      "options": [
        {
          "id": 1,
          "name": "샷 추가",
          "price": 500
        },
        {
          "id": 2,
          "name": "시럽 추가",
          "price": 0
        }
      ]
    }
  ]
}
```

##### GET /api/menus/:id
특정 메뉴의 상세 정보를 조회합니다.
- **요청**: URL 파라미터로 메뉴 ID
- **응답**: 메뉴 상세 정보 및 옵션 목록

##### PUT /api/menus/:id/stock
메뉴의 재고 수량을 수정합니다.
- **요청**:
```json
{
  "stock_quantity": 15
}
```
- **응답**: 수정된 메뉴 정보

#### 6.3.2 주문 관련 API

##### POST /api/orders
새로운 주문을 생성합니다.
- **요청**:
```json
{
  "order_items": [
    {
      "menu_id": 1,
      "menu_name": "아메리카노(ICE)",
      "quantity": 2,
      "options": ["샷 추가"],
      "item_price": 4500,
      "total_price": 9000
    }
  ],
  "total_amount": 9000
}
```
- **응답**:
```json
{
  "success": true,
  "data": {
    "order_id": 123,
    "order_time": "2024-01-15T10:30:00Z",
    "total_amount": 9000,
    "status": "pending"
  }
}
```

##### GET /api/orders
주문 목록을 조회합니다.
- **요청**: 쿼리 파라미터 (status, page, limit)
- **응답**: 주문 목록 및 페이징 정보

##### GET /api/orders/:id
특정 주문의 상세 정보를 조회합니다.
- **요청**: URL 파라미터로 주문 ID
- **응답**: 주문 상세 정보

##### PUT /api/orders/:id/status
주문 상태를 변경합니다.
- **요청**:
```json
{
  "status": "accepted"
}
```
- **응답**: 업데이트된 주문 정보

#### 6.3.3 관리자 관련 API

##### GET /api/admin/dashboard
관리자 대시보드 통계 정보를 조회합니다.
- **요청**: 없음
- **응답**:
```json
{
  "success": true,
  "data": {
    "total_orders": 25,
    "pending_orders": 3,
    "accepted_orders": 5,
    "completed_orders": 17
  }
}
```

### 6.4 데이터베이스 관계

#### 6.4.1 테이블 관계도
```
Menus (1) ----< Options (N)
Menus (1) ----< Orders (N) [주문 아이템을 통해]
```

#### 6.4.2 인덱스 설계
- **Menus**: name, stock_quantity에 인덱스
- **Orders**: order_time, status에 인덱스
- **Options**: menu_id에 외래키 인덱스

### 6.5 에러 처리

#### 6.5.1 공통 에러 응답 형식
```json
{
  "success": false,
  "error": {
    "code": "INVALID_REQUEST",
    "message": "잘못된 요청입니다.",
    "details": "필수 필드가 누락되었습니다."
  }
}
```

#### 6.5.2 주요 에러 코드
- `MENU_NOT_FOUND`: 메뉴를 찾을 수 없음
- `INSUFFICIENT_STOCK`: 재고 부족
- `ORDER_NOT_FOUND`: 주문을 찾을 수 없음
- `INVALID_STATUS`: 잘못된 주문 상태
- `VALIDATION_ERROR`: 입력 데이터 검증 실패

### 6.6 성능 고려사항

#### 6.6.1 데이터베이스 최적화
- 자주 조회되는 메뉴 정보는 캐싱 고려
- 주문 통계는 실시간 계산 대신 주기적 배치 처리 고려
- 대용량 주문 데이터 처리를 위한 페이징 구현

#### 6.6.2 API 최적화
- 메뉴 목록 조회 시 옵션 정보를 JOIN으로 한 번에 조회
- 주문 상태 변경 시 재고 업데이트를 트랜잭션으로 처리
- 불필요한 데이터 전송 방지를 위한 응답 필드 선택

### 6.7 보안 고려사항

#### 6.7.1 입력 검증
- 모든 입력 데이터에 대한 유효성 검사
- SQL Injection 방지를 위한 파라미터화된 쿼리 사용
- XSS 방지를 위한 입력 데이터 이스케이핑

#### 6.7.2 접근 제어
- 관리자 기능에 대한 접근 권한 검증
- API 요청 빈도 제한 (Rate Limiting)
- CORS 설정으로 프론트엔드 도메인만 허용